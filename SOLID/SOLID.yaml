- SOLID principles are all interwined or interdependent
- They are most effective when they are combined together
- It it important to have wholesome view of all principles

- Single Responsibility Principle (SRP):
    - S in SOLID - Single Responsibility Principle (SRP)
    - Every software component should have one and only one responsibility
    - component can be a class, a method or a module
    - Smaller and well organized code than monolithic ones
    - Testing:
        - A class with one responsibility will have far fewer test cases
    - Cohesion:
        - It is the degree to which the various parts of a software components are related
        - Aim for higher cohesion
    - Coupling:
        - It is defined as the level of inter dependency between various software components
        - Aim for loose coupling [fewer dependencies]

- Open Closed Principle (OCP):
    - O in SOLID - Open Closed Principle
    - software components should be closed for modification, but open for extension
    - Following this can lead to cost benefit for a long run
    - Closed for modification:
        - New feature getting added to the software component should not have to modify existing code
    - Open for Extension:
        - A software component should be extendable to add a new feature or to add a new behavior to it
    - Easy to add feature
    - Leads to minimal cost of developing and testing software
    - It requires decoupling, which in turn automatically follows SRP
    - cons:
        - Don't follow this blindly
        - this will end up with huge number of classes that will complicate overall design
        - make an sibjective rather than objective decision

- Liskov Substituion Principle (LSV):
    - L in SOLID - Liskov Substituion Principle (LSV)
    - Objects should be replaceable with their subtypes without affecting the correctness of the program
    - If class A is a subtype of class B, We should be able to replace B with A without disrupting the behavior of program

- Interface Segregation:
    - I in SOLID - Interface Segregation
    - Larger interface should be split into smaller ones
    -

- Dependency Inversion:
    - D in SOLID - Dependency Inversion
    - It refers to decoupling of software modules
    - In this way, instead of high level modules depending on low level modules, both will be depend on abstractions
